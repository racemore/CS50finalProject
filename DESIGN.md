Requirements.txt
This file contains the following terms in order to pre install libraries for the program: cs50, Flask, Flask-Session, requests, flask_mail, random-password-generator. It is important to note that one cannot use “pip3 install password_generator” to install the password generator library. Instead, “pip3 install random-password-generator” is required; for more information about how to use the library, read this source: https://pypi.org/project/random-password-generator/.


weebtube.db
The WeebTube database contains eight tables - anime, users, friends, messages, watchparty, participants, ratings, and favorites. The anime table contains all of the information related to each anime from the 2018 MyAnimeList Kaggle Database (https://www.kaggle.com/azathoth42/myanimelist) extracted from MyAnimeList (https://myanimelist.net/). The users table contains information about each user on the site. The friends table stores information about friendships between users and friend requests. The pending column is set to 1 if the friend request has not been accepted yet and 0 if two users are friends. The messages table stores all relevant information about each message sent on the site. The deleted_sender and deleted_recipient columns are changed to 1 from 0 when the sender or recipient, respectively, delete a message. The watchparty table contains information about each watch party created on the site. The participants table contains the participants of each watch party. The pending column is set to 0 if the user is attending, 1 if they have not responded yet, 2 if they declined, and 3 if they originally accepted and then declined. The ratings table contains all of the ratings made by users on the site and all important information tied to them. The favorites table contains the favorite shows of each user on the site. The rank indicates the order in which the user added titles to their favorites.


helpers.py
This file contains all of the helper functions that are utilized in application.py.

apology(message, code=400)
This function is from CS50 Finance. It renders the inputted message as an apology to the user.

standard_date(date_str)
This function takes a date generated by SQL and returns the date as a string in the format Month abbreviation Day, Year.

html_datetime(date_str):
This function takes a timestamp generated by SQL and returns the date as string in the format read by an input of type datetime-local in html (YYYY-MM-DDTHH:MM).

login_required(f):
This function is from CS50 Finance. It serves to “decorate routes to require login”, essentially redirecting the user to the login page when they try to access a page that requires them to be logged in.


errorhandler(e)
This function, originally from CS50 Finance, checks for errors and returns an apology depending on the type of error. This function was altered for the project so that a 404 error (unknown page) results in 404.html being rendered. 404.html is the page that displays the message “Sorry! That page does not exist.”


Login

Route: /login Function: login()
This function is from CS50 finance. Via GET, login.html, the login page, is rendered. Via POST, a user is logged in, meaning their id is stored in session, if they provide a valid username and password combination. After logging in, they are then redirected to the home page - the “/” route. Error messages are flashed if they provide an incorrect username and/or password or do not input a username and/or password.


Register

Route: /register Function: register()
Most of this function is from CS50 finance. Via GET, register.html, the page that users can register on, is rendered. Via POST, information provided by the user (username and email), if valid, is inserted into the users table in the WeebTube database. Passwords are hashed, and the hash is inserted into the database rather than the password itself. The function checks for several errors. If the username is taken or not provided, an error message is displayed. If the username and/or password is longer than 20 characters, then error messages are flashed. If the password and confirmation password do not match, an error message is flashed. If the email address provided does not have the format alphanum@alphanum.alphanum, then an error message is flashed. A success message is flashed if no errors are encountered and then the user is redirected to /login.


Forgot Password

Route: /forgot-password Function: forgotPassword()
Via GET, the user is redirected to the forgot_password.html page. Via POST, the user must submit a valid username with a matching email address. This feature will be determined by a SQL query; if empty, an error message will be displayed. If the query is not empty, a password will be generated using an imported PasswordGenerator function, and this information along with the user’s username will be updated in an email template (reset_password.html) that is sent to the user’s email address.


New/Change Password

Route: /new-password Function: newPassword()
Via GET, new_password.html is rendered for the user. Via POST, if a valid username and password combination are entered and the new password matches with the confirmation password, the users table will be updated so that the hash of the new password will replace the former password hash in the database and the user is redirected to /. Error messages are flashed and the page is refreshed if the user does not provide a valid username/password combination and/or the new passwords do not match.


Homepage

Route: / Function: index()
This function updates the homepage (titled top_tem.html) with the latest rankings of anime on the site. A SQL query is used to generate a list of shows with details such as title, image_url, genre, episodes, rating. The query data will update the table on the homepage according to the highest rating in descending order.


Rate

Route: /rate Function: rate()
Via GET, the program renders the rate.html or “Rate A Show” page template which contains input boxes for the title, rating, and comment the user would like to create. Via POST, the function will determine if the title in the title input box is within the anime table in weebtube.db. This check will consider either the english title (noted as “title_english” in the database) or romanized Japanese title (noted as “title” in the database) when searching if the input exists. The SQL query within the function also accounts for case insensitivity by adding a set lowercase function for all titles and the input. If nothing is generated from the query, a flash message will be sent towards the top of the screen to let the user know that they inserted an invalid title. Another check is included to ensure that a proper integer rating is used. While there is a min and max limit for integers within rate.html, we ensured that the if statement that checks if the value as an integer also checks for the limits. Users may decide to tamper with the integrity of the html, so the limits are also checked within application.py. Next, the function determines whether the user already rated the title, and if so, their rating history will update and replace the previous rating and comment (if included) with the new information. If the user never rated the show before, another line is added to the ratings table in weebtube.db with the information from the page. These rating updates also alter the anime table in the database. The table in the homepage will showcase the average of all updated ratings of users for shows, rounded to the nearest hundredth to manage irrational numbers like 3.333333… .


Rating History

Route: /history/<username> Function: history(username)
This function serves to register the rating history based on a valid username parameter. The /history/<username> route is tied to a profile page’s “Recent Activity” table. Including this function allows users to see their own rating history on their profile or other people’s profiles after clicking “View Profile” on the “Community Page.” The function conducts a SQL query to generate the selected user’s rated show titles, ratings, comments, and timestamp of ratings.

Route: /user-history Function: userHistory(username)
This function serves to redirect to the logged in user’s rating history (/history/username where username belongs to logged in user). The /user-history route is used for the link tied to “Rating History” in the nav section in layout.html.


Profile

Route: /profile/<username> Function: profile(username)
This function renders the profile corresponding to the user with “username”. If the username is not in the database, 404.html is rendered. If a valid username is provided, several SQL statements are executed to retrieve a dict about information about the user (user_info), a list of dicts containing information about their top five shows (favorites), whether or not the username belongs to the user logged in (isLoggedInUser), and a list of dicts containing information about their three most recent ratings from their rating history (show_history). These variables are then used to help determine the contents of profile.html using Jinja, and profile.html is ultimately rendered for the user.

Route: /edit-profile Function: editProfile()
Via GET, info about the user is retrieved via a SQL Select statement. Then the page, edit_profile.html, is rendered with the variables user_info, genders (a list of genders), and current_date updating the contents of the page via Jinja. Via POST, information provided by the user to update their profile is retrieved, the entry corresponding to the user in the database is updated with the new information, and the user is redirected to /user-profile.

Route: /user-profile Function: userProfile()
This function serves to redirect to the logged in user’s profile (/profile/username where username belongs to logged in user). The /user-profile route is used for the link tied to “Profile” in the nav section in layout.html.


Favorites

Route: /favorites/<username> Function: favorites(username)
This function renders the favorites page belonging to the user with the username provided. If the username is not in the database, 404.html is rendered. Using a SQL Select statement, a list of dicts containing information about each of the users favorites is stored in the variable “favorites”. The favorites, username, and isLoggedInUser variables help determine the contents of favorites.html with the help of Jinja, and then favorites.html is rendered.

Route: /user-favorites Function: userFavorites()
This function serves to redirect to the logged in user’s favorites (/favorites/username where username belongs to logged in user). The /user-favorites route is used for the link tied to “Favorites” in the nav section in layout.html.

Route: /add-favorites Function: addFavorites()
Via GET, add_favorites.html is rendered with variables numFavorites, the number of favorites the user currently has, and maxTitles, the maximum number of favorites a user can have. If numFavorites is equal to maxTitles, then a disabled button labeled with “Cannot add more than [maxTitles]” will be displayed rather than the “Update Favorites” button. Via POST, the favorites table will be updated with the user_id, anime_id corresponding to the title input, and rank. The SQL query to retrieve information about the selected title is case-insensitive and accepts the title in English or romanized Japanese to allow for more valid inputs by the user. The user will be alerted via a flash whether they successfully added the anime to their favorites.

Route: /remove-favorites Function: removeFavorites()
Via GET, remove_favorites.html is rendered with a variable named favorites that is a list of dicts containing information about each of the user’s favorite anime. Using Jinja, each of the titles is an option belonging to a select tag for the user to choose from. Via POST, based on the title deleted and the user logged in, the corresponding entry in the favorites table is deleted and all other entries with the user’s id under user_id have their ranks updated accordingly and the page refreshes. If the user does not select a title, an alert is flashed telling the user to select one.


Friends

Route: /friends Function: friends()
Via GET, friends.html is rendered with the variables friends, a list of the user’s friends retrieved via an SQL query, and requests, the number of incoming friend requests the user has retrieved via SQL query. For each friend in friends, the entry under the key ‘friend_date’ is updated via the standard_date function to have the format Month Day, Year. Via POST, a friend request is sent to the user with the username input by the username and an entry containing the logged in user’s id and the requested user’s id is entered into the friends table in the database and pending is set to 1 (true). The function checks for several errors: if the input user is the logged in user themself, if the user has to respond to the input user’s request, if the input user does not exist, and if the input user has yet to respond to a friend request sent previously. If the user has to respond to the input user’s friend request, they will be redirected to /friend-requests.

Route: /remove-friend Function: removeFriend()
Via GET, this function redirects to /friends. Via POST, this function deletes the entries related to the friendship between the user and the friend they wish to unfriend in the friends table. In friends.html, the form that submits to /remove-friend has a hidden input with the id of the friend to be deleted that is submitted when the “Unfriend” button is selected.


Searching

Route: /user-search Function: userSearch()
This function returns a jsonified list containing usernames that match the user’s query. This function is used with the JavaScript function userSearch(input_id) to allow users to search for other users on the site.

Route: /title-search Function: titleSearch()
This function returns a jsonified list containing titles (English and romanized Japanese) that match the user’s query. This function is used with the JavaScript function titleSearch(input_id) to allow users to search for anime on the site.


Community

Route: /community Function: community()
This function renders community.html with the variable users, a list of dicts containing information about each user on the site. The entry in each dict under the key ‘date_joined’ is changed to Month Day, Year format via the standard_date function. Using Jinja, each row of the table on community.html displays information about each user based on users. Users are displayed in alphabetical order based on username to make finding users easier.


Inbox

Route: /inbox Function: inbox()
This function renders inbox.html with variables friend_requests, watch_party_requests, and messages. Retrieved through a SQL query, friend_requests is a list containing dicts with information related to each incoming friend request for a user. Watch_party_requests, retrieved through a SQL query on the users, watchparty, and participants tables and updated with information from another SQL query to retrieve information about the watch party host from the users table, is a list of dicts containing information about each watch party request. Messages, retrieved from a SQL query on the users and messages tables, is a list containing dicts with information about each message sent to the user. Using Jinja and the variables provided to render_template, the three tables, Friend Requests, Watch Party Requests, and Messages, contain information about each friend request, watch party request, and message, respectively.

Route: /compose-message Function: composeMessage()
Via GET, compose_message.html is rendered with the variable friends, which is a list that was retrieved via a SQL query containing dicts with the id and username of each of the user’s friends. For each friend in friends, using a Jinja for loop, each option inside the select tag corresponds to one of the user’s friends. This allows the user to select the friend they wish to send their message to. Via POST, the messages table is updated with information tied to the message they wish to send and the user is redirected to /inbox. If an invalid username is entered, an alert is flashed and the page is refreshed.

Route: /sent-messages Function: sentMessages()
Via GET, sent_messages.html is rendered with the variable messages - a list of dicts containing information about each sent message retrieved via a SQL query. The information tied to each message in messages is displayed in each row of the table in sent_messages.html using a Jinja for loop. Via POST, the messages table is updated so that deleted_sender = 1 for the message that the user chose to delete and the page is refreshed. The deleted message no longer appears on the “sent” page for the user.

Route: /remove-messages Function: removeMessages()
Via GET, the function redirects the user to /inbox. Via POST, the messages table is updated so that deleted_recipient = 1 for the message that the user chose to delete and the user is redirected to /inbox. The deleted message no longer appears on the “inbox” page for the user.

Route: /friend-requests Function: friendRequests()
Via GET, the function redirects the user to /inbox#friend_req - the friend request table in the user’s inbox. Via POST, if the user accepts the friend request, the friends table will be updated so that the two users are reflected as friends of one another. If the user declines the friend request, the entry in the friends table corresponding to the request is deleted. Regardless of the user’s response to the request, they are redirected to /inbox.

Route: /watch-party-requests Function: watchPartyRequests()
The user’s id is stored prior to examining if GET or POST is used because the variable is used in both cases. Via GET, the user is redirected to the inbox, specifically at the site of watch party requests using /inbox#watch_party. Via POST, which is initiated by either clicking the “Accept” or “Decline” button to a watch party invitation, the watch party id value is identified. If the request is denied, the participants table in weebtube.db will update at the corresponding line where the participant is equal to the user’s id and the host_id is the same as in the inbox line. Specifically, “pending” will be given a value of 3 in the database. Accepted invitations change “pending” to 0, and the watch party information is updated in watchparty_main.html under the “Participating” table.
Note that denied requests are not deleted from the database because this data could be analyzed to observe how users utilize the watch party feature on the site. Once either button is pressed, the user is no longer pending, so the table row in the inbox is deleted.


Watch Party

Route: /create-watch-party Function: createWatchParty()
This function loads the logged in user’s friend username list. Via GET, the user is redirected to the create watchparty page (watchparty_request.html) with stored values for the friend list and current time to update the calendar meeting input to ensure that the user does not attempt to schedule a meeting for a day already passed. Via POST, the function checks if at least one valid friend selection is made along with ensuring that the link submitted is from a kosmi room because all urls contain “https://app.kosmi.io/room/.” The function also checks if a valid title is used and a date/time is scheduled. If the time interferes with another watchparty the user is hosting, an invalid message occurs. Additionally, if a valid title is made, a variable stores the true title with correct capitalization according to the “title” column in the anime table within weebtube.db. Lastly, an optional comment is stored in the “watchparty” table in the database. If the user types nothing into the box, a default message is stored and sent to pending participants. Otherwise, at a bare minimum, the room link is required so that participants can access the room on the day of the event.

Route: /watch-party Function: watchPartyRecords()
This function stores multiple SQL queries to be displayed as tables within the “Watch Party” main page. If at least one participant accepts the invitation (pending = 0), the “hosting” variable will contain the watch party information along with the participant(s) attending. Similarly, pending requests (pending = 1) will appear in the “allPending” query. “Available” checks if all participants are either pending or going to the event. If not, the “noneAvailable” SQL query occurs. The “Available” query is included rather than simply running “noneAvaiable” as this would save some running time because the query selects less columns or features from the database. This is quite useful especially in cases where all people are pending or accepted. A SQL query is also run under “joining” to generate the list of watch parties the logged in user will attend. Additionally, the dates for all queries except “Available”/”notAvailable” are reformatted for simplicity in legibility on the watch party tables.

Route: /watch-party-cancel Function: cancel()
The logged in user has the option to either cancel a watch party they are hosting or their accepted invitation to another host’s event. If the “Cancel” button is clicked, the function reads the table row’s host id and watch party id. The user’s id is then compared to the host id to see if they are the same; if so, all table rows containing the watch party information (including other users’ requests pending in their inboxes) are deleted. If the user cancels as a participant, only their table row under “Participating” is deleted and the host will be aware of the user’s cancellation since their name is no longer in pending or accepted requests.


styles.css
While stylesheets are loaded within layout.html for bootstrap items, a separate stylesheet was created for the website to avoid the constant use of style tags within items in html files such as creating a format to display user information on the portfolio page. This file assisted with the aesthetics from the site in an efficient manner from various abilities ranging from alternating colors for rows in all tables to setting the background to a single image that covers the webpages.


script.js
This file serves to consolidate all JavaScript functions in one place.

titleSearch(input_id)
This function was modified from the search code provided in Week 9’s notes. It serves to query for anime titles by getting the /title-search?q= route concatenated with the user’s input as they type, and it updates the html so that a dropdown list with titles (English and Japanese) based on the search appears.

userSearch(input_id)
This function was modified from the search code provided in Week 9’s notes. It serves to query for usernames by getting the /user-search?q= route concatenated with the user’s input as they type, and it updates the html so that a dropdown list with usernames based on the search appears.

selectMultiple()
This function was modified from discussion and example code files in Stack Overflow: (https://stackoverflow.com/questions/50895806/bootstrap-4-multiselect-dropdown). It serves to utilize the friend list generated in createWatchParty() to display possible individuals the user may select to share the invitation to. The bootstrap tool also queries inputs to suggest possible names that contain the string. No more than 10 friends can be added at a time, and one must select from the dropdown for the name to be valid.